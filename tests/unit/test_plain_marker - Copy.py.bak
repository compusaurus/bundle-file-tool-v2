# ============================================================================
# SOURCEFILE: test_plain_marker.py
# RELPATH: bundle_file_tool_v2/tests/unit/test_plain_marker.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.0
# LIFECYCLE: Proposed
# DESCRIPTION: Unit tests for PlainMarkerProfile - v1.x compatibility
# ============================================================================

"""
Unit tests for PlainMarkerProfile.

Tests parsing, formatting, round-trip fidelity, and v1.x compatibility.
Critical for ensuring zero-regression from v1.1.5.
"""

import pytest
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../src')))

from core.profiles.plain_marker import PlainMarkerProfile
from core.models import BundleManifest, BundleEntry
from core.exceptions import ProfileParseError, ProfileFormatError


class TestPlainMarkerProfileBasics:
    """Tests for basic profile properties."""
    
    def test_profile_name(self, plain_marker_profile):
        """Test profile identifier."""
        assert plain_marker_profile.profile_name == 'plain_marker'
    
    def test_display_name(self, plain_marker_profile):
        """Test human-readable name."""
        display = plain_marker_profile.get_display_name()
        
        assert 'Plain Marker' in display or 'Legacy' in display
    
    def test_capabilities(self, plain_marker_profile):
        """Test declared capabilities."""
        caps = plain_marker_profile.get_capabilities()
        
        assert caps['supports_binary'] is True
        assert caps['supports_metadata'] is True
        # Plain marker v1.x didn't have checksums
        assert caps['supports_checksums'] is False


class TestPlainMarkerDetection:
    """Tests for format detection."""
    
    def test_detect_valid_plain_marker(self, plain_marker_profile):
        """Test detection of valid plain marker format."""
        text = """# ===================================================================
# FILE: test.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
print('hello')
"""
        
        assert plain_marker_profile.detect_format(text) is True
    
    def test_detect_without_separators(self, plain_marker_profile):
        """Test detection works even without separator lines."""
        text = """# FILE: test.py
print('hello')
"""
        
        assert plain_marker_profile.detect_format(text) is True
    
    def test_detect_case_insensitive(self, plain_marker_profile):
        """Test detection is case-insensitive."""
        text = """# file: test.py
content
"""
        
        assert plain_marker_profile.detect_format(text) is True
    
    def test_detect_non_plain_marker(self, plain_marker_profile):
        """Test rejection of non-plain-marker format."""
        text = """This is just regular text
with no file markers
"""
        
        assert plain_marker_profile.detect_format(text) is False
    
    def test_detect_markdown_fence(self, plain_marker_profile):
        """Test rejection of markdown fence format."""
        text = """<!-- FILE: test.py -->
```python
print('hello')
```
"""
        
        assert plain_marker_profile.detect_format(text) is False


class TestPlainMarkerParsing:
    """Tests for parsing plain marker format."""
    
    def test_parse_single_file(self, plain_marker_profile):
        """Test parsing bundle with single file."""
        text = """# ===================================================================
# FILE: src/main.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
def main():
    pass
"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        assert manifest.get_file_count() == 1
        assert manifest.profile == 'plain_marker'
        
        entry = manifest.entries[0]
        assert entry.path == 'src/main.py'
        assert 'def main()' in entry.content
        assert entry.is_binary is False
        assert entry.encoding == 'utf-8'
        assert entry.eol_style == 'LF'
    
    def test_parse_multiple_files(self, plain_marker_profile):
        """Test parsing bundle with multiple files."""
        text = """# ===================================================================
# FILE: file1.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
content1

# ===================================================================
# FILE: file2.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
content2
"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        assert manifest.get_file_count() == 2
        assert manifest.entries[0].path == 'file1.py'
        assert manifest.entries[1].path == 'file2.py'
    
    def test_parse_binary_file(self, plain_marker_profile):
        """Test parsing binary file with base64."""
        text = """# ===================================================================
# FILE: image.png
# META: encoding=base64; eol=n/a; mode=binary
# ===================================================================
iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB
"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        entry = manifest.entries[0]
        assert entry.is_binary is True
        assert entry.encoding == 'base64'
        assert entry.eol_style == 'n/a'
        assert 'iVBORw0KG' in entry.content
    
    def test_parse_without_meta(self, plain_marker_profile):
        """Test parsing without META line uses defaults."""
        text = """# FILE: test.txt
content here
"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        entry = manifest.entries[0]
        assert entry.encoding == 'utf-8'  # Default
        assert entry.eol_style == 'LF'     # Default
        assert entry.is_binary is False    # Default
    
    def test_parse_empty_content(self, plain_marker_profile):
        """Test parsing file with empty content."""
        text = """# FILE: empty.txt
# META: encoding=utf-8; eol=LF; mode=text

"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        entry = manifest.entries[0]
        assert entry.content == ''
    
    def test_parse_windows_eol(self, plain_marker_profile):
        """Test parsing with CRLF line endings."""
        text = "# FILE: test.txt\r\n# META: encoding=utf-8; eol=CRLF; mode=text\r\ncontent\r\n"
        
        manifest = plain_marker_profile.parse_stream(text)
        
        entry = manifest.entries[0]
        assert entry.eol_style == 'CRLF'
    
    def test_parse_no_files_raises_error(self, plain_marker_profile):
        """Test parsing empty bundle raises error."""
        text = """# Just some comments
# No actual files
"""
        
        with pytest.raises(ProfileParseError, match='No files found'):
            plain_marker_profile.parse_stream(text)
    
    def test_parse_preserves_path_separators(self, plain_marker_profile):
        """Test that paths are normalized to forward slashes."""
        text = """# FILE: src\\windows\\path.py
content
"""
        
        manifest = plain_marker_profile.parse_stream(text)
        
        # BundleEntry normalizes to forward slashes
        assert manifest.entries[0].path == 'src/windows/path.py'


class TestPlainMarkerFormatting:
    """Tests for formatting bundles."""
    
    def test_format_single_file(self, plain_marker_profile):
        """Test formatting bundle with single file."""
        entry = BundleEntry(
            path='test.py',
            content='print("hello")\n',
            is_binary=False,
            encoding='utf-8',
            eol_style='LF'
        )
        
        manifest = BundleManifest(
            entries=[entry],
            profile='plain_marker'
        )
        
        output = plain_marker_profile.format_manifest(manifest)
        
        assert '# FILE: test.py' in output
        assert '# META: encoding=utf-8; eol=LF; mode=text' in output
        assert 'print("hello")' in output
        assert '# ===' in output  # Separator lines
    
    def test_format_multiple_files(self, plain_marker_profile):
        """Test formatting multiple files."""
        entries = [
            BundleEntry(path='file1.py', content='content1', is_binary=False, encoding='utf-8', eol_style='LF'),
            BundleEntry(path='file2.py', content='content2', is_binary=False, encoding='utf-8', eol_style='LF')
        ]
        
        manifest = BundleManifest(entries=entries, profile='plain_marker')
        
        output = plain_marker_profile.format_manifest(manifest)
        
        assert output.count('# FILE:') == 2
        assert 'file1.py' in output
        assert 'file2.py' in output
    
    def test_format_binary_file(self, plain_marker_profile):
        """Test formatting binary file."""
        entry = BundleEntry(
            path='image.png',
            content='base64datahere',
            is_binary=True,
            encoding='base64',
            eol_style='n/a'
        )
        
        manifest = BundleManifest(entries=[entry], profile='plain_marker')
        
        output = plain_marker_profile.format_manifest(manifest)
        
        assert '# META: encoding=base64; eol=n/a; mode=binary' in output
        assert 'base64datahere' in output
    
    def test_format_with_crlf(self, plain_marker_profile):
        """Test formatting file with CRLF."""
        entry = BundleEntry(
            path='windows.txt',
            content='content',
            is_binary=False,
            encoding='utf-8',
            eol_style='CRLF'
        )
        
        manifest = BundleManifest(entries=[entry], profile='plain_marker')
        
        output = plain_marker_profile.format_manifest(manifest)
        
        assert 'eol=CRLF' in output


class TestPlainMarkerRoundTrip:
    """Tests for round-trip fidelity (critical for v1.x compatibility)."""
    
    def test_roundtrip_single_text_file(self, plain_marker_profile):
        """Test parse → format → parse preserves content."""
        original_text = """# ===================================================================
# FILE: test.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
def hello():
    print("world")
"""
        
        # Parse
        manifest1 = plain_marker_profile.parse_stream(original_text)
        
        # Format
        formatted = plain_marker_profile.format_manifest(manifest1)
        
        # Parse again
        manifest2 = plain_marker_profile.parse_stream(formatted)
        
        # Verify equivalence
        assert manifest2.get_file_count() == manifest1.get_file_count()
        assert manifest2.entries[0].path == manifest1.entries[0].path
        assert manifest2.entries[0].content == manifest1.entries[0].content
        assert manifest2.entries[0].encoding == manifest1.entries[0].encoding
    
    def test_roundtrip_multiple_files(self, plain_marker_profile, sample_manifest):
        """Test round-trip with multiple files."""
        # Format
        formatted = plain_marker_profile.format_manifest(sample_manifest)
        
        # Parse back
        manifest2 = plain_marker_profile.parse_stream(formatted)
        
        # Verify file count preserved
        assert manifest2.get_file_count() == sample_manifest.get_file_count()
        
        # Verify all paths present
        paths1 = sorted([e.path for e in sample_manifest.entries])
        paths2 = sorted([e.path for e in manifest2.entries])
        assert paths1 == paths2
    
    def test_roundtrip_binary_file(self, plain_marker_profile, sample_binary_entry):
        """Test round-trip with binary file."""
        manifest1 = BundleManifest(
            entries=[sample_binary_entry],
            profile='plain_marker'
        )
        
        formatted = plain_marker_profile.format_manifest(manifest1)
        manifest2 = plain_marker_profile.parse_stream(formatted)
        
        assert manifest2.entries[0].is_binary is True
        assert manifest2.entries[0].content == sample_binary_entry.content
    
    def test_roundtrip_preserves_encoding(self, plain_marker_profile):
        """Test round-trip preserves encoding metadata."""
        entry = BundleEntry(
            path='win.txt',
            content='content',
            is_binary=False,
            encoding='windows-1252',
            eol_style='CRLF'
        )
        
        manifest1 = BundleManifest(entries=[entry], profile='plain_marker')
        formatted = plain_marker_profile.format_manifest(manifest1)
        manifest2 = plain_marker_profile.parse_stream(formatted)
        
        assert manifest2.entries[0].encoding == 'windows-1252'
        assert manifest2.entries[0].eol_style == 'CRLF'


class TestPlainMarkerValidation:
    """Tests for manifest validation."""
    
    def test_validate_valid_manifest(self, plain_marker_profile, sample_manifest):
        """Test validation passes for valid manifest."""
        # Should not raise
        plain_marker_profile.validate_manifest(sample_manifest)
    
    def test_validate_binary_files_allowed(self, plain_marker_profile, sample_binary_entry):
        """Test validation allows binary files."""
        manifest = BundleManifest(
            entries=[sample_binary_entry],
            profile='plain_marker'
        )
        
        # Should not raise - plain marker supports binary
        plain_marker_profile.validate_manifest(manifest)
    
    def test_validate_fixes_missing_eol(self, plain_marker_profile):
        """Test validation fixes missing EOL style."""
        entry = BundleEntry(
            path='test.txt',
            content='content',
            is_binary=False,
            encoding='utf-8',
            eol_style=''  # Missing
        )
        entry.eol_style = ''  # Force invalid
        
        manifest = BundleManifest(entries=[entry], profile='plain_marker')
        
        # Validation should fix this
        plain_marker_profile.validate_manifest(manifest)
        
        assert entry.eol_style in ['LF', 'n/a']


class TestPlainMarkerV115Compatibility:
    """Tests for v1.1.5 backward compatibility."""
    
    def test_parse_v115_bundle(self, plain_marker_profile, sample_plain_marker_bundle):
        """Test parsing v1.1.5 style bundle."""
        manifest = plain_marker_profile.parse_stream(sample_plain_marker_bundle)
        
        assert manifest.get_file_count() > 0
        assert manifest.profile == 'plain_marker'
    
    def test_format_compatible_with_v115(self, plain_marker_profile, sample_text_entry):
        """Test formatted output is compatible with v1.1.5 parser."""
        manifest = BundleManifest(entries=[sample_text_entry], profile='plain_marker')
        
        output = plain_marker_profile.format_manifest(manifest)
        
        # Should have v1.x format markers
        assert '# FILE:' in output
        assert '# META:' in output
        assert '# ===' in output


# ============================================================================
# LIFECYCLE STATUS: Proposed
# COVERAGE: Complete PlainMarkerProfile parse/format/round-trip testing
# CRITICAL: These tests ensure zero-regression from v1.1.5
# NEXT STEPS: Add integration test with actual v1.1.5 bundle file
# ============================================================================
