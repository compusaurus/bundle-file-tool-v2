# ===================================================================
# FILE: base.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
# ============================================================================
# FILE: base.py
# RELPATH: bundle_file_tool_v2/src/core/profiles/base.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.0
# LIFECYCLE: Proposed
# DESCRIPTION: Abstract base class defining the profile interface contract
# ARCHITECT: George (specification in Response to v2.1k3 Assessment)
# ============================================================================

"""
Profile Base Interface for Bundle File Tool v2.1.

This module defines the abstract base class that all bundle format profiles
must implement, ensuring a consistent interface for the parser and writer.
"""

from abc import ABC, abstractmethod
from typing import Dict
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from core.models import BundleManifest
from core.exceptions import ProfileParseError, ProfileFormatError, EncodingError


class ProfileBase(ABC):
    """
    Abstract base class for all bundle format profiles.
    
    This class defines the contract that all profile implementations (e.g., PlainMarker,
    MarkdownFence) must adhere to, ensuring a consistent interface for the parser and writer.
    
    All concrete profile classes must:
    1. Inherit from ProfileBase
    2. Implement all abstract methods
    3. Override get_capabilities() if supporting advanced features
    """

    @property
    @abstractmethod
    def profile_name(self) -> str:
        """
        Return the unique, machine-readable identifier for the profile.
        
        The profile name is used for:
        - Configuration file references (e.g., bundle_profile: "plain_marker")
        - Profile selection in the UI
        - Logging and diagnostics
        
        Returns:
            Lowercase string identifier (e.g., 'plain_marker', 'md_fence', 'jsonl')
            
        Example:
            >>> profile = PlainMarkerProfile()
            >>> profile.profile_name
            'plain_marker'
        """
        pass

    @abstractmethod
    def detect_format(self, text: str) -> bool:
        """
        Quickly and efficiently detect if the given text appears to match this profile's format.
        
        This method should operate on a small snippet of text (e.g., the first 1-2KB)
        to avoid performance issues during auto-detection. It should use heuristics
        to identify format markers specific to the profile.
        
        Design Notes:
        - Must be fast - will be called sequentially during auto-detection
        - Should be conservative - false positives are worse than false negatives
        - Look for format-specific markers (e.g., "# FILE:" for plain_marker)
        - Consider checking first 10-20 lines only
        
        Args:
            text: A snippet of the bundle text (typically first 1-2KB or 20 lines)
            
        Returns:
            True if the text is likely in this profile's format, False otherwise
            
        Example:
            >>> profile = PlainMarkerProfile()
            >>> text = "# FILE: src/example.py\\ndef main(): pass"
            >>> profile.detect_format(text)
            True
        """
        pass

    @abstractmethod
    def parse_stream(self, text: str) -> BundleManifest:
        """
        Parse the raw bundle text into a BundleManifest object according to the profile's grammar.
        
        This is the core parsing method. It must:
        1. Identify file boundaries using profile-specific markers
        2. Extract file paths, content, and metadata
        3. Handle encoding declarations
        4. Decode base64 content for binary files
        5. Create BundleEntry objects with proper attributes
        6. Return a complete BundleManifest
        
        Error Handling:
        - Raise ProfileParseError for malformed bundle structure
        - Raise EncodingError for encoding issues
        - Include line numbers in error messages when possible
        - Provide clear, actionable error messages for users
        
        Args:
            text: The raw bundle file content as a string
            
        Returns:
            A BundleManifest object containing all extracted entries
            
        Raises:
            ProfileParseError: If the text is malformed and cannot be parsed
            EncodingError: If the content within the bundle has an invalid or unexpected encoding
            
        Example:
            >>> profile = PlainMarkerProfile()
            >>> text = "# FILE: test.py\\nprint('hello')"
            >>> manifest = profile.parse_stream(text)
            >>> manifest.get_file_count()
            1
        """
        pass

    @abstractmethod
    def format_manifest(self, manifest: BundleManifest) -> str:
        """
        Format a BundleManifest object into the profile's specific text representation.
        
        This is the core formatting method. It must:
        1. Iterate through all entries in the manifest
        2. Format each entry according to profile syntax
        3. Include metadata (encoding, EOL, checksums if supported)
        4. Ensure proper line endings
        5. Return a complete, parseable bundle string
        
        Round-Trip Guarantee:
        - The output of this method should be parseable by parse_stream()
        - parse_stream(format_manifest(manifest)) should produce equivalent manifest
        
        Error Handling:
        - Raise ProfileFormatError if manifest contains incompatible data
        - Example: Binary files in a profile that doesn't support them
        
        Args:
            manifest: The BundleManifest object to format
            
        Returns:
            The formatted bundle text as a string
            
        Raises:
            ProfileFormatError: If the manifest contains data that is incompatible with the
                                profile's capabilities (e.g., trying to format a binary file
                                in a profile that does not support it)
                                
        Example:
            >>> profile = PlainMarkerProfile()
            >>> manifest = BundleManifest(entries=[...], profile='plain_marker')
            >>> text = profile.format_manifest(manifest)
            >>> '# FILE:' in text
            True
        """
        pass

    def get_capabilities(self) -> Dict[str, bool]:
        """
        Declare the capabilities of this profile.
        
        This allows the application to make intelligent decisions, such as:
        - Warning users if they try to bundle binary files with an unsupported profile
        - Disabling checksum verification for profiles that don't support it
        - Filtering profile options based on bundle content
        
        Base Implementation:
        - Default assumes minimal capabilities (text-only, no checksums)
        - Subclasses should override to declare their actual capabilities
        
        Returns:
            A dictionary of supported features:
            - 'supports_binary': Can handle base64-encoded binary files
            - 'supports_checksums': Can store/verify SHA-256 checksums
            - 'supports_metadata': Can store encoding/EOL metadata
            - 'supports_compression': Can compress content (future)
            
        Example:
            >>> profile = MarkdownFenceProfile()
            >>> caps = profile.get_capabilities()
            >>> caps['supports_binary']
            True
            >>> caps['supports_checksums']
            True
        """
        return {
            'supports_binary': False,
            'supports_checksums': False,
            'supports_metadata': False,
        }
    
    def get_display_name(self) -> str:
        """
        Return a human-readable display name for the profile.
        
        This is used in the UI for profile selection dropdowns and labels.
        Base implementation converts profile_name to title case.
        Subclasses can override for custom display names.
        
        Returns:
            Human-readable profile name
            
        Example:
            >>> profile = PlainMarkerProfile()
            >>> profile.get_display_name()
            'Plain Marker'
        """
        return self.profile_name.replace('_', ' ').title()
    
    def validate_manifest(self, manifest: BundleManifest) -> None:
        """
        Validate that a manifest is compatible with this profile.
        
        This is called before format_manifest() to catch issues early.
        Base implementation checks basic compatibility.
        Subclasses can override for profile-specific validation.
        
        Args:
            manifest: The manifest to validate
            
        Raises:
            ProfileFormatError: If manifest is incompatible with profile
            
        Example:
            >>> profile = PlainMarkerProfile()
            >>> manifest = BundleManifest(entries=[binary_entry], profile='plain_marker')
            >>> profile.validate_manifest(manifest)  # May raise ProfileFormatError
        """
        capabilities = self.get_capabilities()
        
        # Check for binary files if not supported
        if not capabilities['supports_binary']:
            binary_files = [e.path for e in manifest.entries if e.is_binary]
            if binary_files:
                raise ProfileFormatError(
                    self.profile_name,
                    f"Profile does not support binary files. Found: {', '.join(binary_files[:3])}"
                )
        
        # Check for checksums if not supported
        if not capabilities['supports_checksums']:
            checksum_files = [e.path for e in manifest.entries if e.checksum is not None]
            if checksum_files:
                # This is just a warning - we can format without checksums
                pass


# ============================================================================
# LIFECYCLE STATUS: Proposed
# NEXT STEPS: Implement concrete profile classes (PlainMarker, MarkdownFence, JSONL)
# DEPENDENCIES: models.py, exceptions.py
# TESTS: Abstract class tests, concrete implementations will have full test suites
# SPECIFICATION: Defined by George in "Response to v2.1k3 Assessment" document
# ============================================================================

# ===================================================================
# FILE: plain_marker.py
# META: encoding=utf-8; eol=LF; mode=text
# ===================================================================
# ============================================================================
# FILE: plain_marker.py
# RELPATH: bundle_file_tool_v2/src/core/profiles/plain_marker.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.0
# LIFECYCLE: Proposed
# DESCRIPTION: Plain Marker profile - legacy v1.x format for backward compatibility
# ============================================================================

"""
Plain Marker Profile Implementation.

This profile maintains compatibility with the Bundle File Tool v1.x format,
using simple "# FILE: path" markers to delimit files. It ensures zero-regression
for existing users and bundles.

Format Example:
    # ===================================================================
    # FILE: src/example.py
    # META: encoding=utf-8; eol=LF; mode=text
    # ===================================================================
    def hello():
        print("Hello, World!")
    
    # ===================================================================
    # FILE: data/image.png
    # META: encoding=base64; eol=n/a; mode=binary
    # ===================================================================
    iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1Pe...
"""

import re
import base64
from typing import List, Dict, Tuple, Optional
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from core.profiles.base import ProfileBase
from core.models import BundleManifest, BundleEntry
from core.exceptions import ProfileParseError, ProfileFormatError, EncodingError


class PlainMarkerProfile(ProfileBase):
    """
    Plain Marker format profile (v1.x compatibility).
    
    This profile uses the original Bundle File Tool format with:
    - "# FILE: path" headers to mark file boundaries
    - Optional "# META: " lines for encoding/eol/mode metadata
    - Base64 encoding for binary files
    - Simple text content with no special escaping
    """
    
    # Regex patterns for parsing
    HEADER_PATTERN = re.compile(r'^\s*#\s*={50,}\s*$')
    FILE_PATTERN = re.compile(r'^\s*#\s*FILE\s*:\s*(.+?)\s*$', re.IGNORECASE)
    META_PATTERN = re.compile(r'^\s*#\s*META\s*:\s*(.+?)\s*$', re.IGNORECASE)
    
    # Metadata parsing
    META_FIELD_PATTERN = re.compile(r'(\w+)=([^;]+)')
    
    @property
    def profile_name(self) -> str:
        """Return profile identifier."""
        return 'plain_marker'
    
    def get_display_name(self) -> str:
        """Return human-readable name."""
        return 'Plain Marker (Legacy)'
    
    def get_capabilities(self) -> Dict[str, bool]:
        """Declare profile capabilities."""
        return {
            'supports_binary': True,      # Via base64
            'supports_checksums': False,  # Not in v1.x format
            'supports_metadata': True,    # Via META lines
        }
    
    def detect_format(self, text: str) -> bool:
        """
        Detect if text is in plain marker format.
        
        Looks for characteristic "# FILE:" headers in the first 20 lines.
        """
        lines = text.split('\n')[:20]
        for line in lines:
            if self.FILE_PATTERN.match(line):
                return True
        return False
    
    def parse_stream(self, text: str) -> BundleManifest:
        """
        Parse plain marker format into BundleManifest.
        
        Format:
            # ===================================================================
            # FILE: path/to/file.ext
            # META: encoding=utf-8; eol=LF; mode=text
            # ===================================================================
            [file content here]
            
        The META line is optional. If absent, defaults are used.
        """
        entries = []
        current_entry = None
        current_metadata = {}
        line_number = 0
        
        lines = text.splitlines(keepends=True)
        
        for line in lines:
            line_number += 1
            
            # Check for FILE marker
            file_match = self.FILE_PATTERN.match(line)
            if file_match:
                # Save previous entry if exists
                if current_entry is not None:
                    entries.append(self._finalize_entry(current_entry, current_metadata))
                
                # Start new entry
                path = file_match.group(1).strip()
                current_entry = {
                    'path': path,
                    'content': '',
                    'line_start': line_number
                }
                current_metadata = {}
                continue
            
            # Check for META line
            meta_match = self.META_PATTERN.match(line)
            if meta_match and current_entry is not None:
                meta_str = meta_match.group(1)
                current_metadata = self._parse_metadata(meta_str)
                continue
            
            # Check for separator line (ignore it)
            if self.HEADER_PATTERN.match(line):
                continue
            
            # Accumulate content
            if current_entry is not None:
                current_entry['content'] += line
        
        # Don't forget the last entry
        if current_entry is not None:
            entries.append(self._finalize_entry(current_entry, current_metadata))
        
        # Create manifest
        if not entries:
            raise ProfileParseError(
                self.profile_name,
                "No files found in bundle",
                line_number=0
            )
        
        return BundleManifest(
            entries=entries,
            profile=self.profile_name,
            metadata={
                'format_version': '1.x',
                'parser': 'PlainMarkerProfile'
            }
        )
    
    def _parse_metadata(self, meta_str: str) -> Dict[str, str]:
        """
        Parse metadata string into dictionary.
        
        Example: "encoding=utf-8; eol=LF; mode=text"
        Returns: {'encoding': 'utf-8', 'eol': 'LF', 'mode': 'text'}
        """
        metadata = {}
        for match in self.META_FIELD_PATTERN.finditer(meta_str):
            key = match.group(1).strip()
            value = match.group(2).strip()
            metadata[key] = value
        return metadata
    
    def _finalize_entry(self, entry_dict: dict, metadata: dict) -> BundleEntry:
        """
        Convert raw entry dict and metadata into BundleEntry object.
        
        Args:
            entry_dict: Dict with 'path' and 'content' keys
            metadata: Dict with optional 'encoding', 'eol', 'mode' keys
            
        Returns:
            Properly configured BundleEntry
        """
        path = entry_dict['path']
        content = entry_dict['content']
        
        # Extract metadata with defaults
        encoding = metadata.get('encoding', 'utf-8')
        eol_style = metadata.get('eol', 'LF')
        mode = metadata.get('mode', 'text')
        
        # Determine if binary
        is_binary = (mode == 'binary')
        
        # Strip trailing newline from content (added during parsing)
        if content and content.endswith('\n'):
            content = content[:-1]
        
        return BundleEntry(
            path=path,
            content=content,
            is_binary=is_binary,
            encoding=encoding,
            eol_style=eol_style,
            checksum=None  # Plain marker format doesn't include checksums
        )
    
    def format_manifest(self, manifest: BundleManifest) -> str:
        """
        Format BundleManifest into plain marker format.
        
        Output format:
            # ===================================================================
            # FILE: path/to/file.ext
            # META: encoding=utf-8; eol=LF; mode=text
            # ===================================================================
            [content]
            
        Binary files are included as base64 with mode=binary.
        """
        self.validate_manifest(manifest)
        
        output_lines = []
        
        for entry in manifest.entries:
            # Header separator
            output_lines.append('# ' + ('=' * 67))
            
            # FILE line
            output_lines.append(f'# FILE: {entry.path}')
            
            # META line
            mode = 'binary' if entry.is_binary else 'text'
            meta_parts = [
                f'encoding={entry.encoding}',
                f'eol={entry.eol_style}',
                f'mode={mode}'
            ]
            output_lines.append(f'# META: {"; ".join(meta_parts)}')
            
            # Footer separator
            output_lines.append('# ' + ('=' * 67))
            
            # Content
            output_lines.append(entry.content)
            
            # Ensure trailing newline (unless content already has one)
            if not entry.content.endswith('\n'):
                output_lines.append('')
        
        return '\n'.join(output_lines)
    
    def validate_manifest(self, manifest: BundleManifest) -> None:
        """
        Validate manifest for plain marker format.
        
        This profile supports binary files, so no additional validation needed
        beyond the base class checks.
        """
        # Call base validation
        super().validate_manifest(manifest)
        
        # Plain marker specific validation
        for entry in manifest.entries:
            # Ensure encoding is specified
            if not entry.encoding:
                raise ProfileFormatError(
                    self.profile_name,
                    f"File '{entry.path}' missing encoding specification"
                )
            
            # Warn if eol_style is not set properly
            if not entry.eol_style or entry.eol_style not in {'LF', 'CRLF', 'CR', 'MIXED', 'n/a'}:
                # Use default
                entry.eol_style = 'n/a' if entry.is_binary else 'LF'


# ============================================================================
# LIFECYCLE STATUS: Proposed
# NEXT STEPS: Integration testing with sample_project_plain_marker.txt
# DEPENDENCIES: base.py, models.py, exceptions.py
# TESTS: Unit tests for parsing and formatting, round-trip tests
# COMPATIBILITY: Maintains full v1.x format compatibility
# ============================================================================
