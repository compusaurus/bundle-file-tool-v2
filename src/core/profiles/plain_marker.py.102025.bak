# ============================================================================
# FILE: plain_marker.py
# RELPATH: bundle_file_tool_v2/src/core/profiles/plain_marker.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.0
# LIFECYCLE: Proposed
# DESCRIPTION: Plain Marker profile - legacy v1.x format for backward compatibility
# ============================================================================

"""
Plain Marker Profile Implementation.

This profile maintains compatibility with the Bundle File Tool v1.x format,
using simple "# FILE: path" markers to delimit files. It ensures zero-regression
for existing users and bundles.

Format Example:
    # ===================================================================
    # FILE: src/example.py
    # META: encoding=utf-8; eol=LF; mode=text
    # ===================================================================
    def hello():
        print("Hello, World!")
    
    # ===================================================================
    # FILE: data/image.png
    # META: encoding=base64; eol=n/a; mode=binary
    # ===================================================================
    iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1Pe...
"""

import re
import base64
from typing import List, Dict, Tuple, Optional
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from core.profiles.base import ProfileBase
from core.models import BundleManifest, BundleEntry
from core.exceptions import ProfileParseError, ProfileFormatError, EncodingError


class PlainMarkerProfile(ProfileBase):
    """
    Plain Marker format profile (v1.x compatibility).
    
    This profile uses the original Bundle File Tool format with:
    - "# FILE: path" headers to mark file boundaries
    - Optional "# META: " lines for encoding/eol/mode metadata
    - Base64 encoding for binary files
    - Simple text content with no special escaping
    """
    
    # Regex patterns for parsing
    HEADER_PATTERN = re.compile(r'^\s*#\s*={50,}\s*$')
    FILE_PATTERN = re.compile(r'^\s*#\s*FILE\s*:\s*(.+?)\s*$', re.IGNORECASE)
    META_PATTERN = re.compile(r'^\s*#\s*META\s*:\s*(.+?)\s*$', re.IGNORECASE)
    
    # Metadata parsing
    META_FIELD_PATTERN = re.compile(r'(\w+)=([^;]+)')
    
    @property
    def profile_name(self) -> str:
        """Return profile identifier."""
        return 'plain_marker'
    
    def get_display_name(self) -> str:
        """Return human-readable name."""
        return 'Plain Marker (Legacy)'
    
    def get_capabilities(self) -> Dict[str, bool]:
        """Declare profile capabilities."""
        return {
            'supports_binary': True,      # Via base64
            'supports_checksums': False,  # Not in v1.x format
            'supports_metadata': True,    # Via META lines
        }
    
    def detect_format(self, text: str) -> bool:
        """
        Detect if text is in plain marker format.
        
        Looks for characteristic "# FILE:" headers in the first 20 lines.
        """
        lines = text.split('\n')[:20]
        for line in lines:
            if self.FILE_PATTERN.match(line):
                return True
        return False
    
    def parse_stream(self, text: str) -> BundleManifest:
        """
        Parse plain marker format into BundleManifest.
        
        Format:
            # ===================================================================
            # FILE: path/to/file.ext
            # META: encoding=utf-8; eol=LF; mode=text
            # ===================================================================
            [file content here]
            
        The META line is optional. If absent, defaults are used.
        """
        entries = []
        current_entry = None
        current_metadata = {}
        line_number = 0
        
        lines = text.splitlines(keepends=True)
        
        for line in lines:
            line_number += 1
            
            # Check for FILE marker
            file_match = self.FILE_PATTERN.match(line)
            if file_match:
                # Save previous entry if exists
                if current_entry is not None:
                    entries.append(self._finalize_entry(current_entry, current_metadata))
                
                # Start new entry
                path = file_match.group(1).strip()
                current_entry = {
                    'path': path,
                    'content': '',
                    'line_start': line_number
                }
                current_metadata = {}
                continue
            
            # Check for META line
            meta_match = self.META_PATTERN.match(line)
            if meta_match and current_entry is not None:
                meta_str = meta_match.group(1)
                current_metadata = self._parse_metadata(meta_str)
                continue
            
            # Check for separator line (ignore it)
            if self.HEADER_PATTERN.match(line):
                continue
            
            # Accumulate content
            if current_entry is not None:
                current_entry['content'] += line
        
        # Don't forget the last entry
        if current_entry is not None:
            entries.append(self._finalize_entry(current_entry, current_metadata))
        
        # Create manifest
        if not entries:
            raise ProfileParseError(
                self.profile_name,
                "No files found in bundle",
                line_number=0
            )
        
        return BundleManifest(
            entries=entries,
            profile=self.profile_name,
            metadata={
                'format_version': '1.x',
                'parser': 'PlainMarkerProfile'
            }
        )
    
    def _parse_metadata(self, meta_str: str) -> Dict[str, str]:
        """
        Parse metadata string into dictionary.
        
        Example: "encoding=utf-8; eol=LF; mode=text"
        Returns: {'encoding': 'utf-8', 'eol': 'LF', 'mode': 'text'}
        """
        metadata = {}
        for match in self.META_FIELD_PATTERN.finditer(meta_str):
            key = match.group(1).strip()
            value = match.group(2).strip()
            metadata[key] = value
        return metadata
    
    # ============================================================================
    # LOCATION: src/core/profiles/plain_marker.py
    # CLASS: PlainMarkerProfile
    # METHOD: _finalize_entry
    # REPLACEMENT: Complete method - correctly handles trailing newlines
    # ============================================================================

    def _finalize_entry(self, entry_dict: dict, metadata: dict) -> BundleEntry:
        """
        Convert raw entry dict and metadata into BundleEntry object.
        
        Args:
            entry_dict: Dict with 'path' and 'content' keys
            metadata: Dict with optional 'encoding', 'eol', 'mode' keys
            
        Returns:
            Properly configured BundleEntry
        """
        path = entry_dict['path']
        content = entry_dict['content']
        
        # Extract metadata with defaults
        encoding = metadata.get('encoding', 'utf-8')
        eol_style = metadata.get('eol', 'LF')
        mode = metadata.get('mode', 'text')
        
        # Determine if binary
        is_binary = (mode == 'binary')
        
        # Process content based on mode
        if is_binary:
            # For binary files, the content is already a base64 string. Just strip whitespace.
            content = content.strip()
        else:
            # For text files, handle line endings
            # If content has any content and ends with a newline from the bundle format,
            # remove exactly one trailing newline to account for the format's separation
            if content and content.endswith('\n'):
                content = content[:-1]
        
        return BundleEntry(
            path=path,
            content=content,
            is_binary=is_binary,
            encoding=encoding,
            eol_style=eol_style,
            checksum=None  # Plain marker format doesn't include checksums
        )
    
    def format_manifest(self, manifest: BundleManifest) -> str:
        """
        Format BundleManifest into plain marker format.
        
        Output format:
            # ===================================================================
            # FILE: path/to/file.ext
            # META: encoding=utf-8; eol=LF; mode=text
            # ===================================================================
            [content]
            
        Binary files are included as base64 with mode=binary.
        """
        self.validate_manifest(manifest)
        
        output_lines = []
        
        for entry in manifest.entries:
            # Header separator
            output_lines.append('# ' + ('=' * 67))
            
            # FILE line
            output_lines.append(f'# FILE: {entry.path}')
            
            # META line
            mode = 'binary' if entry.is_binary else 'text'
            meta_parts = [
                f'encoding={entry.encoding}',
                f'eol={entry.eol_style}',
                f'mode={mode}'
            ]
            output_lines.append(f'# META: {"; ".join(meta_parts)}')
            
            # Footer separator
            output_lines.append('# ' + ('=' * 67))
            
            # Content handling depends on mode
            if entry.is_binary:
                # Binary content needs base64 encoding
                try:
                    if isinstance(entry.content, str):
                        # If it's already base64 encoded string, decode to bytes first
                        try:
                            content = base64.b64decode(entry.content)
                        except:
                            content = entry.content.encode('utf-8')
                    else:
                        content = entry.content
                    b64_content = base64.b64encode(content).decode('ascii')
                    output_lines.append(b64_content)
                except Exception as e:
                    raise EncodingError(entry.path, entry.encoding, f"Failed to encode binary content: {e}")
            else:
                # Text content - preserve exactly as is.
                output_lines.append(entry.content)
            
            # Add empty line between entries
            output_lines.append('')
        
        # Remove trailing empty line after last entry
        if output_lines and not output_lines[-1]:
            output_lines.pop()
        
        return '\n'.join(output_lines)
    
    def validate_manifest(self, manifest: BundleManifest) -> None:
        """
        Validate manifest for plain marker format.
        
        This profile supports binary files, so no additional validation needed
        beyond the base class checks.
        """
        # Call base validation
        super().validate_manifest(manifest)
        
        # Plain marker specific validation
        for entry in manifest.entries:
            # Ensure encoding is specified
            if not entry.encoding:
                raise ProfileFormatError(
                    self.profile_name,
                    f"File '{entry.path}' missing encoding specification"
                )
            
            # Warn if eol_style is not set properly
            if not entry.eol_style or entry.eol_style not in {'LF', 'CRLF', 'CR', 'MIXED', 'n/a'}:
                # Use default
                entry.eol_style = 'n/a' if entry.is_binary else 'LF'


# ============================================================================
# LIFECYCLE STATUS: Proposed
# NEXT STEPS: Integration testing with sample_project_plain_marker.txt
# DEPENDENCIES: base.py, models.py, exceptions.py
# TESTS: Unit tests for parsing and formatting, round-trip tests
# COMPATIBILITY: Maintains full v1.x format compatibility
# ============================================================================
