# ============================================================================
# SOURCEFILE: plain_marker.py
# RELPATH: bundle_file_tool_v2/src/core/profiles/plain_marker.py
# PROJECT: Bundle File Tool v2.1
# VERSION: 2.1.8
# STATUS: In Development
# DESCRIPTION:
#   Plain Marker profile (legacy v1.x compatibility).
#   Fixes included (v2.1.8):
#     - Defensive parse (no None indexing; META is optional).
#     - Ignore empty/"dot-only" # FILE: headers (prevents bogus entries).
#     - Duplicate paths consolidated with last-one-wins (v1.x behavior).
#     - format_manifest() always emits bundle_format_diagnostic.log.
#     - SYMMETRY FIXES (2025-10-25):
#       * _trim_header_spacing: Empty content normalizes to "", not '\n'
#       * _trim_header_spacing: Binary content always strips trailing newlines
#       * _finalize: eol_style guaranteed fallback (never empty string)
#       * format_manifest binary: No unconditional '\n' after base64 payload
#       * format_manifest text: Add trailing=false when no trailing newline
#       * validate_manifest: Added to fix empty eol_style on validation call
# ============================================================================

"""
Plain Marker format profile (v2.1 rules, backward compatible with v1.x bundles).

Responsibilities:
- Detect bundle format
- Parse bundle text into a BundleManifest
- Format a BundleManifest back into bundle text
- Emit diagnostic logging for bundle creation

Transport format (bundle text):
    # ===================================================================
    # FILE: path/inside/project.py
    # META: encoding=utf-8; eol=LF; mode=text; trailing=false
    # ===================================================================
    <file content...>

IMPORTANT:
- The bundle uses FILE/META headers.
- The on-disk repo files use SOURCEFILE/RELPATH/... headers. That is handled
  by the extraction writer, NOT here.
- META trailing=false indicates the original file did not have a trailing newline

Team: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
Version: 2.1.8
Lifecycle: Proposed
Changelog:
  - 2025-10-25: Applied symmetry fixes per George/Paul analysis of test failures
  - 2025-10-25 v2: Fixed binary roundtrip and validate_manifest
  - 2025-10-25 v3: Fixed trailing newline roundtrip with META trailing=false
"""

from __future__ import annotations

import base64
import logging
import re
from typing import Dict, List, Optional, Tuple

from core.profiles.base import ProfileBase
from core.models import BundleManifest, BundleEntry
from core.exceptions import ProfileParseError, ProfileFormatError


class PlainMarkerProfile(ProfileBase):
    """
    Plain Marker format profile (v2.1).
    """

    # Lines that look like "# ========" etc.
    HEADER_PATTERN = re.compile(r"^\s*#\s*={50,}\s*$")

    # "# FILE: some/relative/path"
    FILE_PATTERN = re.compile(r"^\s*#\s*FILE\s*:\s*(.+?)\s*$", re.IGNORECASE)

    # "# META: key=value; key=value; ..."
    META_PATTERN = re.compile(r"^\s*#\s*META\s*:\s*(.+?)\s*$", re.IGNORECASE)

    # inside META, split "key=value"
    META_FIELD_PATTERN = re.compile(r"(\w+)\s*=\s*([^;]+)")

    @property
    def profile_name(self) -> str:
        return "plain_marker"

    def get_display_name(self) -> str:
        return "Plain Marker (Legacy-Compatible)"

    def get_capabilities(self) -> Dict[str, bool]:
        return {
            "supports_binary": True,
            "supports_checksums": False,
            "supports_metadata": True,
        }

    def detect_format(self, text: str) -> bool:
        """Detect if text appears to use '# FILE:' markers."""
        for line in text.splitlines()[:20]:
            if self.FILE_PATTERN.match(line):
                return True
        return False

    # ------------------------------------------------------------------
    # Parsing (bundle -> manifest)
    # ------------------------------------------------------------------

    def parse_stream(self, text: str) -> BundleManifest:
        """
        Parse plain-marker bundle text into a BundleManifest.

        Rules:
        - "# FILE: <path>" begins a new file block.
        - "# META: key=value; ..." is optional; later keys override earlier.
        - Separator lines (====) are ignored.
        - Empty, dot-only, or root-only paths after "# FILE:" are skipped.
        - For duplicate paths, last one wins.

        Returns:
            BundleManifest(entries=[BundleEntry,...], profile="plain_marker", ...)
        Raises:
            ProfileParseError if we didn't find any valid file blocks.
        """

        entries: List[BundleEntry] = []
        current_block: Optional[Dict[str, str]] = None
        current_meta: Dict[str, str] = {}

        for line_no, line in enumerate(text.splitlines(keepends=True), start=1):
            m_file = self.FILE_PATTERN.match(line)
            if m_file:
                # flush previous file block (if any) before starting a new one
                if current_block is not None:
                    current_block["content"] = self._trim_header_spacing(
                        current_block["content"], current_meta
                    )
                    entries.append(self._finalize(current_block, current_meta))

                raw_path = (m_file.group(1) or "").strip()

                # invalid target paths get skipped entirely
                if not raw_path or raw_path in {".", "./", ".\\", "/"}:
                    current_block = None
                    current_meta = {}
                    continue

                current_block = {
                    "path": raw_path,
                    "content": "",
                    "line_start": line_no,
                }
                current_meta = {}
                continue

            m_meta = self.META_PATTERN.match(line)
            if m_meta and current_block is not None:
                # merge/override metadata as we go
                current_meta.update(self._parse_meta(m_meta.group(1)))
                continue

            # ignore separator borders
            if self.HEADER_PATTERN.match(line):
                continue

            if current_block is not None:
                current_block["content"] += line

        # flush last block
        if current_block is not None:
            current_block["content"] = self._trim_header_spacing(
                current_block["content"], current_meta
            )
            entries.append(self._finalize(current_block, current_meta))

        if not entries:
            raise ProfileParseError(
                self.profile_name, "No files found in bundle", line_no if "line_no" in locals() else 0
            )

        # De-dupe by path with "last one wins"
        seen = set()
        consolidated: List[BundleEntry] = []
        for e in reversed(entries):
            if e.path not in seen:
                seen.add(e.path)
                consolidated.append(e)
        consolidated.reverse()

        manifest = BundleManifest(
            entries=consolidated,
            profile=self.profile_name,
            metadata={
                "format_version": "2.1",
                "parser": "PlainMarkerProfile",
            },
        )
        return manifest

    # ------------------------------------------------------------------
    # Formatting (manifest -> bundle text)
    # ------------------------------------------------------------------

    def format_manifest(self, manifest: BundleManifest) -> str:
        """
        Convert a BundleManifest to plain-marker text (the bundle file).

        Also writes bundle_format_diagnostic.log with details for debugging.
        This MUST remain in place per team directive.
        """

        self._validate_before_format(manifest)

        logger = logging.getLogger("bundle.format_diagnostic")
        logger.setLevel(logging.DEBUG)

        # Make sure we always log fresh for this run
        if not logger.handlers:
            fh = logging.FileHandler(
                "bundle_format_diagnostic.log", mode="w", encoding="utf-8"
            )
            fh.setLevel(logging.DEBUG)
            fmt = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
            fh.setFormatter(fmt)
            logger.addHandler(fh)
            logger.propagate = False

        logger.info("=" * 80)
        logger.info("STARTING format_manifest()")
        logger.info("Manifest contains %d entries", len(manifest.entries))
        logger.info("=" * 80)

        border = "# " + "=" * 67
        out: List[str] = []

        for idx, entry in enumerate(manifest.entries):
            logger.info("\n--- Processing Entry %d/%d ---", idx + 1, len(manifest.entries))
            logger.info(" Path: %s", entry.path)
            logger.info(" Binary: %s", entry.is_binary)
            logger.info(" Encoding: %s", entry.encoding)
            logger.info(" EOL: %s", entry.eol_style)
            logger.info(" Content length: %d chars", len(entry.content))
            logger.info(
                " Content ends with newline: %s",
                entry.content.endswith("\n"),
            )
            logger.info(
                " Content ends with CRLF: %s",
                entry.content.endswith("\r\n"),
            )
            tail = entry.content[-50:] if entry.content else ""
            logger.info(
                " Last 50 chars (repr): %s",
                repr(tail) if tail else "EMPTY",
            )

            mode = "binary" if entry.is_binary else "text"
            encoding = entry.encoding or ("base64" if entry.is_binary else "utf-8")
            eol = entry.eol_style or ("n/a" if entry.is_binary else "LF")

            # FIX 6: Detect if content has trailing newline and record in META
            # This preserves roundtrip fidelity for files without trailing newlines
            has_trailing_newline = entry.content.endswith("\n") if entry.content else False
            
            # Build META line with trailing indicator
            meta_parts = [f"encoding={encoding}", f"eol={eol}", f"mode={mode}"]
            if not has_trailing_newline and not entry.is_binary:
                # For text files without trailing newline, mark it explicitly
                meta_parts.append("trailing=false")
            
            meta_line = "; ".join(meta_parts)

            header = (
                f"{border}\n"
                f"# FILE: {entry.path}\n"
                f"# META: {meta_line}\n"
                f"{border}\n"
            )

            # Binary handling
            if entry.is_binary:
                # binary payload is either already base64 text or raw bytes
                if isinstance(entry.content, str):
                    payload = entry.content.strip()
                elif isinstance(entry.content, (bytes, bytearray)):
                    payload = base64.b64encode(bytes(entry.content)).decode("ascii")
                else:
                    raise ProfileFormatError(
                        self.profile_name,
                        f"Unsupported binary content type: {type(entry.content)}",
                    )
                block = header + payload
                # Only add newline if not already present
                if not block.endswith("\n"):
                    block += "\n"
            else:
                # Text handling
                text_body = entry.content if isinstance(entry.content, str) else str(entry.content)
                block = header + text_body
                # Always ensure block ends with newline for proper formatting
                if not block.endswith("\n"):
                    block += "\n"

            out.append(block)

        logger.info("COMPLETED format_manifest()")
        return "".join(out)

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def _parse_meta(self, meta_str: str) -> Dict[str, str]:
        meta: Dict[str, str] = {}
        for k, v in self.META_FIELD_PATTERN.findall(meta_str):
            meta[k.strip().lower()] = v.strip()
        return meta

    def _trim_header_spacing(self, content: str, meta: Dict[str, str]) -> str:
        """
        Normalize spacing after header block.
        
        FIX 1 (2025-10-25): Empty bodies normalize to '' (not '\\n')
        FIX 3B (2025-10-25): Binary content always strips trailing newlines
        - If file body is effectively empty or just whitespace/newlines,
          normalize to empty string. Tests expect '' for empty content.
        - For binary (mode=binary), always strip trailing newlines (block separator)
        - META trailing=false means strip trailing newline(s) for text
        - Otherwise keep at most one final newline for text
        
        Historical test expectations:
        - Truly empty file content should parse as '' (not '\\n')
        - Binary content shouldn't have trailing newlines (base64 format)
        - If META trailing=false, strip final newline(s)
        - Otherwise, at most one newline of padding is kept
        """
        trailing = (meta.get("trailing") or "").strip().lower()
        mode = (meta.get("mode") or "").strip().lower()

        # FIX 1: Fast path for empty/whitespace-only content
        if content.strip() == "":
            return ""

        # FIX 3B: Binary content always strips trailing newlines
        # (the newline is just a block separator, not part of base64 data)
        if mode == "binary":
            return content.rstrip("\n\r")

        # Text file handling
        # Handle double newline after header
        if content.endswith("\n\n"):
            # If trailing=false, drop both newlines; else drop only one
            return content[:-2] if trailing == "false" else content[:-1]

        # Handle single newline at end
        if trailing == "false" and content.endswith("\n"):
            return content[:-1]

        return content

    def _finalize(self, raw: Dict[str, str], meta: Dict[str, str]) -> BundleEntry:
        """
        FIX 2 (2025-10-25): Guarantee eol_style fallback.
        - Ensure eol_style is never empty string, even if meta.get("eol") was ""
        """
        # normalize path separators to forward slash
        norm_path = raw["path"].replace("\\", "/")

        mode = (meta.get("mode") or "").lower()
        encoding = (meta.get("encoding") or ("base64" if mode == "binary" else "utf-8")).lower()
        is_binary = (mode == "binary") or (encoding == "base64")
        
        # FIX 2: Pick eol_style with guaranteed fallback
        eol_candidate = (meta.get("eol") or "").strip()
        if not eol_candidate:
            eol_candidate = "n/a" if is_binary else "LF"

        return BundleEntry(
            path=norm_path,
            content=raw.get("content", ""),
            is_binary=is_binary,
            encoding=encoding,
            eol_style=eol_candidate,
            checksum=None,
        )

    def validate_manifest(self, manifest: BundleManifest) -> None:
        """
        Validate manifest for plain marker format.
        
        FIX 2B (2025-10-25): Ensures all entries have proper encoding and eol_style.
        This is called by tests and can be called independently of formatting.
        Fixes test_validate_fixes_missing_eol.
        """
        # Call base validation
        super().validate_manifest(manifest)
        
        # Plain marker specific validation and fixes
        for entry in manifest.entries:
            # Ensure encoding is specified
            if not entry.encoding:
                entry.encoding = "base64" if entry.is_binary else "utf-8"
            
            # Ensure eol_style is valid (never empty string)
            if not entry.eol_style:
                entry.eol_style = "n/a" if entry.is_binary else "LF"

    def _validate_before_format(self, manifest: BundleManifest) -> None:
        """
        Sanity check entries before we emit a bundle.
        Ensures encoding/eol defaults are filled so logging is consistent.
        """
        for e in manifest.entries:
            if e.is_binary and (not isinstance(e.content, (str, bytes, bytearray))):
                raise ProfileFormatError(
                    self.profile_name,
                    "Binary entry content must be str/bytes/bytearray",
                )
            if not e.encoding:
                e.encoding = "base64" if e.is_binary else "utf-8"
            if not e.eol_style:
                e.eol_style = "n/a" if e.is_binary else "LF"
