# ============================================================================
# SOURCEFILE: models.py
# RELPATH: bundle_file_tool_v2/src/core/models.py
# PROJECT: Bundle File Tool v2.1
# VERSION: 2.1.1
# LIFECYCLE: Proposed
# DESCRIPTION: Core data models for bundle entries and manifests
# CHANGES: Made is_binary, eol_style, encoding optional with defaults for test compatibility
# ============================================================================

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import hashlib


@dataclass
class BundleEntry:
    """Represents a single file within a bundle."""
    path: str
    content: str
    encoding: str = "utf-8"
    is_binary: bool = False
    eol_style: str = ""
    checksum: Optional[str] = None
    file_size_bytes: Optional[int] = None
    content_type: Optional[str] = None

    def __post_init__(self) -> None:
        """Normalize and validate BundleEntry fields. REQ-MOD-901: Defer content_type semantic validation to profiles."""
        if not self.path:
            raise ValueError("BundleEntry path cannot be empty")
        
        self.path = self.path.replace("\\", "/")
        
        # Infer is_binary from content_type if applicable
        if self.content_type == 'binary' and not self.is_binary:
            self.is_binary = True
        elif self.content_type == 'text' and self.is_binary:
            self.is_binary = False
        
        # REQ-MOD-901: Only type check content_type, not semantic validation
        if self.content_type is not None:
            if not isinstance(self.content_type, str):
                raise TypeError("content_type must be a string if provided")
        
        # Coerce blank EOL to defaults
        if self.eol_style is None or str(self.eol_style).strip() == "":
            self.eol_style = "n/a" if self.is_binary else "LF"
        
        valid_eol = {"LF", "CRLF", "CR", "MIXED", "n/a"}
        if self.eol_style not in valid_eol:
            raise ValueError(f"Invalid eol_style: {self.eol_style}. Must be one of {valid_eol}")
        
        if self.checksum is not None:
            if not (isinstance(self.checksum, str) and len(self.checksum) == 64 and 
                    all(c in '0123456789abcdefABCDEF' for c in self.checksum)):
                raise ValueError(f"Invalid checksum format: {self.checksum}. Must be 64-char hex string")
        
        if self.file_size_bytes is not None:
            if not isinstance(self.file_size_bytes, int) or self.file_size_bytes < 0:
                raise ValueError(f"Invalid file_size_bytes: {self.file_size_bytes}. Must be non-negative integer")
    
    def calculate_checksum(self) -> str:
        return hashlib.sha256(self.content.encode('utf-8')).hexdigest()
    
    def verify_checksum(self) -> bool:
        if self.checksum is None:
            return True
        return self.calculate_checksum() == self.checksum.lower()


@dataclass
class BundleManifest:
    """Container for an entire bundle with metadata."""
    entries: List[BundleEntry]
    profile: str
    version: str = "2.1"
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not isinstance(self.entries, list):
            raise TypeError("entries must be a list")
        if not self.profile:
            raise ValueError("profile cannot be empty")
        if self.metadata is None:
            self.metadata = {}
        elif not isinstance(self.metadata, dict):
            raise TypeError("metadata must be a dictionary")
        paths = [entry.path for entry in self.entries]
        if len(paths) != len(set(paths)):
            duplicates = {p for p in paths if paths.count(p) > 1}
            raise ValueError(f"Duplicate file paths found: {duplicates}")
    
    def get_entry(self, path: str) -> Optional[BundleEntry]:
        normalized_path = path.replace('\\', '/')
        for entry in self.entries:
            if entry.path == normalized_path:
                return entry
        return None
    
    def get_file_count(self) -> int:
        return len(self.entries)
    
    def get_binary_count(self) -> int:
        return sum(1 for entry in self.entries if entry.is_binary)
    
    def get_text_count(self) -> int:
        return sum(1 for entry in self.entries if not entry.is_binary)
    
    def get_total_size_bytes(self) -> int:
        return sum(entry.file_size_bytes for entry in self.entries if entry.file_size_bytes is not None)
    
    def verify_all_checksums(self) -> Dict[str, bool]:
        results = {}
        for entry in self.entries:
            if entry.checksum is not None:
                results[entry.path] = entry.verify_checksum()
        return results
    
    def add_entry(self, entry: BundleEntry) -> None:
        if self.get_entry(entry.path) is not None:
            raise ValueError(f"Entry with path '{entry.path}' already exists")
        self.entries.append(entry)
    
    def remove_entry(self, path: str) -> bool:
        normalized_path = path.replace('\\', '/')
        for i, entry in enumerate(self.entries):
            if entry.path == normalized_path:
                del self.entries[i]
                return True
        return False
