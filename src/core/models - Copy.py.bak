# ============================================================================
# SOURCEFILE: models.py
# RELPATH: bundle_file_tool_v2/src/core/models.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.1
# LIFECYCLE: Proposed
# STATUS: FIXED - Relaxed path validation per Paul's analysis v3
# DESCRIPTION: Core data models for bundle entries and manifests
# ============================================================================

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import hashlib


@dataclass
class BundleEntry:
    """
    Represents a single file within a bundle.
    
    Attributes:
        path: Relative path of the file within the project
        content: File content as string (UTF-8 or base64 if binary)
        is_binary: True if content is base64-encoded binary data
        encoding: Original file encoding
        eol_style: End-of-line style
        checksum: Optional SHA-256 hex string for integrity verification
        file_size_bytes: Optional original file size in bytes
        content_type: Optional 'text' or 'binary' hint (REQ-MOD-001)
    """
    path: str
    content: str = ""
    is_binary: bool = False
    encoding: str = "utf-8"
    eol_style: str = "LF"
    checksum: Optional[str] = None
    file_size_bytes: Optional[int] = None
    content_type: Optional[str] = None
    
    def __post_init__(self) -> None:
        """
        Normalize and validate BundleEntry fields.
        
        PAUL'S FIX: Relax path check - allow empty here, let validators catch it later.
        Tests create "minimal" entries with empty paths for validation testing.
        """
        # 1) Path handling: allow empty here (tests create "minimal" entries),
        # downstream validators will flag it when appropriate.
        if self.path is None:
            self.path = ""  # normalize None -> ""
        else:
            self.path = str(self.path)
        
        # Normalize path separators
        self.path = self.path.replace("\\", "/")
        
        # Ensure is_binary has a value
        if self.is_binary is None:
            self.is_binary = False
        
        # Ensure encoding has a value
        if not self.encoding:
            self.encoding = "utf-8"
        
        # REQ-MOD-001: Validate content_type if provided
        if self.content_type is not None:
            if self.content_type not in ('text', 'binary'):
                raise ValueError(
                    f"Invalid content_type: '{self.content_type}'. Must be 'text' or 'binary'"
                )
            
            # Must be semantically consistent with is_binary
            if self.content_type == 'binary' and not self.is_binary:
                raise ValueError(
                    "content_type='binary' but is_binary=False. These must be consistent."
                )
            if self.content_type == 'text' and self.is_binary:
                raise ValueError(
                    "content_type='text' but is_binary=True. These must be consistent."
                )
        
        # Coerce blank/None EOL to defaults
        if self.eol_style is None or str(self.eol_style).strip() == "":
            self.eol_style = "n/a" if self.is_binary else "LF"
        
        # Validate EOL style
        valid_eol = {"LF", "CRLF", "CR", "MIXED", "n/a"}
        if self.eol_style not in valid_eol:
            raise ValueError(f"Invalid eol_style: {self.eol_style}. Must be one of {valid_eol}")
        
        # Validate checksum format if present
        if self.checksum is not None:
            if not (isinstance(self.checksum, str) and 
                    len(self.checksum) == 64 and 
                    all(c in '0123456789abcdefABCDEF' for c in self.checksum)):
                raise ValueError(f"Invalid checksum format: {self.checksum}. Must be 64-char hex string")
        
        # Validate file_size_bytes if present
        if self.file_size_bytes is not None:
            if not isinstance(self.file_size_bytes, int) or self.file_size_bytes < 0:
                raise ValueError(f"Invalid file_size_bytes: {self.file_size_bytes}. Must be non-negative integer")
    
    def calculate_checksum(self) -> str:
        """Calculate SHA-256 checksum of the content."""
        return hashlib.sha256(self.content.encode('utf-8')).hexdigest()
    
    def verify_checksum(self) -> bool:
        """Verify that stored checksum matches current content."""
        if self.checksum is None:
            return True
        return self.calculate_checksum() == self.checksum.lower()


@dataclass
class BundleManifest:
    """Container for an entire bundle with metadata."""
    entries: List[BundleEntry]
    profile: str
    version: str = "2.1"
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate manifest data on initialization."""
        if not isinstance(self.entries, list):
            raise TypeError("entries must be a list")
        
        if not self.profile:
            raise ValueError("profile cannot be empty")
        
        if self.metadata is None:
            self.metadata = {}
        elif not isinstance(self.metadata, dict):
            raise TypeError("metadata must be a dictionary")
        
        # Check for duplicate paths
        paths = [entry.path for entry in self.entries]
        if len(paths) != len(set(paths)):
            duplicates = {p for p in paths if paths.count(p) > 1}
            raise ValueError(f"Duplicate file paths found: {duplicates}")
    
    def get_entry(self, path: str) -> Optional[BundleEntry]:
        """Retrieve a specific entry by path."""
        normalized_path = path.replace('\\', '/')
        for entry in self.entries:
            if entry.path == normalized_path:
                return entry
        return None
    
    def get_file_count(self) -> int:
        """Return total number of files in the bundle."""
        return len(self.entries)
    
    def get_binary_count(self) -> int:
        """Return number of binary files in the bundle."""
        return sum(1 for entry in self.entries if entry.is_binary)
    
    def get_text_count(self) -> int:
        """Return number of text files in the bundle."""
        return sum(1 for entry in self.entries if not entry.is_binary)
    
    def get_total_size_bytes(self) -> int:
        """Return total size of all files in bytes."""
        return sum(entry.file_size_bytes for entry in self.entries if entry.file_size_bytes is not None)
    
    def verify_all_checksums(self) -> Dict[str, bool]:
        """Verify checksums for all entries that have them."""
        results = {}
        for entry in self.entries:
            if entry.checksum is not None:
                results[entry.path] = entry.verify_checksum()
        return results
    
    def add_entry(self, entry: BundleEntry) -> None:
        """Add a new entry to the manifest."""
        if self.get_entry(entry.path) is not None:
            raise ValueError(f"Entry with path '{entry.path}' already exists")
        self.entries.append(entry)
    
    def remove_entry(self, path: str) -> bool:
        """Remove an entry by path."""
        normalized_path = path.replace('\\', '/')
        for i, entry in enumerate(self.entries):
            if entry.path == normalized_path:
                del self.entries[i]
                return True
        return False


# ============================================================================
# LIFECYCLE STATUS: Proposed
# VERSION: 2.1.1
# CHANGES: PAUL'S FIX - Relaxed path validation at construction
# FIXES: test_validate_manifest_with_missing_required_fields (path can be empty now)
# KEEPS: test_validate_manifest_with_invalid_content_type (already correct)
# ============================================================================
