# ============================================================================
# FILE: validators.py
# RELPATH: bundle_file_tool_v2/src/core/validators.py
# PROJECT: Bundle File Tool v2.1
# TEAM: Ringo (Owner), John (Lead Dev), George (Architect), Paul (Lead Analyst)
# VERSION: 2.1.0
# LIFECYCLE: Proposed
# DESCRIPTION: Path validation, glob filtering, and integrity checks
# FIXES: GlobFilter recursive matching, sanitize_filename single underscores
# ============================================================================

"""
Validators Module.

Provides safety checks for path validation, glob pattern matching,
checksum verification, and file size enforcement.
"""

from pathlib import Path
from typing import List, Optional, Set, Iterable, Sequence
import fnmatch
import hashlib
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.exceptions import (
    PathTraversalError,
    GlobFilterError,
    ChecksumMismatchError,
    FileSizeError
)


class PathValidator:
    """
    Validates file paths for safety.
    
    Prevents path traversal attacks and ensures paths stay within
    allowed boundaries.
    """
    
    def __init__(self, base_path: Optional[Path] = None):
        """
        Initialize validator.
        
        Args:
            base_path: Base directory that paths must stay within
        """
        self.base_path = Path(base_path).resolve() if base_path else Path.cwd().resolve()
    
    def validate_path(self, path: Path, *, allow_absolute: bool = False) -> Path:
        """
        Validate that path is safe to use under base_path.
        
        Args:
            path: Path to validate
            allow_absolute: If True, allow absolute paths
            
        Returns:
            Resolved safe path
            
        Raises:
            PathTraversalError: If path is unsafe
        """
        if isinstance(path, str):
            path = Path(path)
        
        # Check for absolute paths (including Windows pseudo-absolute like "/path")
        path_str = str(path)
        is_absolute = path.is_absolute() or path_str.startswith(('/','\\'))
        
        if is_absolute:
            if not allow_absolute:
                raise PathTraversalError(str(path), "Absolute paths not allowed")
            return path.resolve()
        
        # Resolve relative path under base
        try:
            resolved = (self.base_path / path).resolve()
        except Exception as e:
            raise PathTraversalError(str(path), f"Path resolution failed: {e}")
        
        # Ensure resolved path is within base_path
        try:
            resolved.relative_to(self.base_path)
        except ValueError:
            raise PathTraversalError(
                str(path),
                f"Path escapes base directory: {self.base_path}"
            )
        
        return resolved
    
    def validate_paths(self, paths: Iterable[Path], *, allow_absolute: bool = False) -> List[Path]:
        """
        Validate multiple paths.
        
        Args:
            paths: Paths to validate
            allow_absolute: If True, allow absolute paths
            
        Returns:
            List of resolved safe paths
        """
        return [self.validate_path(p, allow_absolute=allow_absolute) for p in paths]
    
    def is_safe_path(self, path: Path) -> bool:
        """
        Check if path is safe without raising exception.
        
        Args:
            path: Path to check
            
        Returns:
            True if safe, False otherwise
        """
        try:
            self.validate_path(path)
            return True
        except PathTraversalError:
            return False
    
    @staticmethod
    def contains_traversal_patterns(path: str) -> bool:
        """
        Check if path string contains traversal patterns.
        
        Args:
            path: Path string to check
            
        Returns:
            True if suspicious patterns found
        """
        suspicious = [
            "..",
            "~",
            "//",
            "\\\\",
        ]
        
        path_lower = path.lower()
        return any(pattern in path_lower for pattern in suspicious)
    
    @staticmethod
    def sanitize_filename(filename: str) -> str:
        """
        Sanitize filename for safe use on Windows/Unix systems.
        
        Replaces path separators and invalid characters with underscores.
        
        Args:
            filename: Filename to sanitize
            
        Returns:
            Sanitized filename safe for file system use
        """
        # Replace path separators with underscores
        safe = filename.replace("/", "_").replace("\\", "_")
        
        # Replace each invalid character with single underscore
        # Windows forbidden: <>:"|?* plus NUL
        invalid_chars = '<>:"|?*\0'
        for char in invalid_chars:
            safe = safe.replace(char, "_")
        
        # Strip leading/trailing dots and spaces (Windows compatibility)
        safe = safe.strip(" .")
        
        # Return "unnamed" if result is empty
        return safe if safe else "unnamed"


class GlobFilter:
    """
    Filters files using glob patterns.
    
    Supports allow lists and deny lists with deny precedence.
    Uses pathlib.PurePosixPath.match() for proper ** recursion support.
    """
    
    def __init__(self,
                 allow_patterns: Optional[Sequence[str]] = None,
                 deny_patterns: Optional[Sequence[str]] = None):
        """
        Initialize filter.
        
        Args:
            allow_patterns: Glob patterns for allowed files (default: ["**/*"])
            deny_patterns: Glob patterns for denied files (default: [])
        """
        self.allow_patterns = list(allow_patterns) if allow_patterns else ["**/*"]
        self.deny_patterns = list(deny_patterns) if deny_patterns else []
        
        # Also support 'allow' and 'deny' aliases for compatibility
        self.allow = self.allow_patterns
        self.deny = self.deny_patterns
        
        # Validate patterns
        for pattern in self.allow_patterns + self.deny_patterns:
            self._validate_pattern(pattern)
    
    def should_include(self, path: str) -> bool:
        """
        Determine if path should be included based on patterns.
        
        Uses pathlib.PurePosixPath.match() which properly handles ** recursion.
        
        Rules:
        - If path matches any deny pattern -> False (deny precedence)
        - If no allow patterns specified -> True (allow by default)
        - If path matches any allow pattern -> True
        - Otherwise -> False
        
        Args:
            path: Path to check (will be normalized to forward slashes)
            
        Returns:
            True if path should be included
        """
        from pathlib import PurePosixPath
        
        # Normalize to POSIX-style for consistent matching
        path_posix = str(path).replace("\\", "/")
        p = PurePosixPath(path_posix)
        
        # Deny patterns take precedence - use pathlib for ** support
        if self.deny_patterns:
            for pattern in self.deny_patterns:
                pattern_posix = str(pattern).replace("\\", "/")
                try:
                    if p.match(pattern_posix):
                        return False
                except ValueError:
                    # Invalid pattern, skip
                    continue
        
        # If no allow patterns, include by default (unless denied above)
        if not self.allow_patterns:
            return True
        
        # Check allow patterns - pathlib.match() handles ** properly
        for pattern in self.allow_patterns:
            pattern_posix = str(pattern).replace("\\", "/")
            try:
                if p.match(pattern_posix):
                    return True
            except ValueError:
                # Invalid pattern, skip
                continue
        
        return False
    
    def filter_paths(self, paths: List[Path], base_path: Optional[Path] = None) -> List[Path]:
        """
        Filter list of paths using patterns.
        
        Args:
            paths: Paths to filter
            base_path: Base path for calculating relative paths
            
        Returns:
            Filtered list of paths
        """
        filtered = []
        for path in paths:
            if base_path:
                try:
                    rel_path = str(path.relative_to(base_path))
                except ValueError:
                    rel_path = str(path)
            else:
                rel_path = str(path)
            
            if self.should_include(rel_path):
                filtered.append(path)
        
        return filtered
    
    def _validate_pattern(self, pattern: str) -> None:
        """
        Validate glob pattern syntax.
        
        Args:
            pattern: Pattern to validate
            
        Raises:
            GlobFilterError: If pattern is invalid
        """
        if not pattern or not isinstance(pattern, str):
            raise GlobFilterError(str(pattern), "Empty or invalid glob pattern")
        
        if not pattern.strip():
            raise GlobFilterError(pattern, "Empty or invalid glob pattern")
        
        # Check for obvious syntax errors
        if pattern.count('[') != pattern.count(']'):
            raise GlobFilterError(pattern, "Unmatched brackets")


class ChecksumValidator:
    """
    Validates file integrity using checksums.
    
    Supports SHA-256 checksums for detecting corruption or tampering.
    """
    
    @staticmethod
    def calculate_checksum(content: str) -> str:
        """
        Calculate SHA-256 checksum of content.
        
        Args:
            content: String content to hash
            
        Returns:
            Lowercase hexadecimal checksum string
        """
        return hashlib.sha256(content.encode('utf-8')).hexdigest().lower()
    
    @staticmethod
    def calculate_file_checksum(file_path: Path) -> str:
        """
        Calculate SHA-256 checksum of file.
        
        Args:
            file_path: Path to file
            
        Returns:
            Lowercase hexadecimal checksum string
        """
        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(8192), b''):
                sha256.update(chunk)
        return sha256.hexdigest().lower()
    
    @staticmethod
    def verify_checksum(content: str, expected: str) -> bool:
        """
        Verify content matches expected checksum.
        
        Args:
            content: Content to verify
            expected: Expected checksum (case-insensitive)
            
        Returns:
            True if checksum matches
        """
        actual = ChecksumValidator.calculate_checksum(content)
        return actual == expected.lower()
    
    @staticmethod
    def verify_or_raise(content: str, expected: str, file_path: str) -> None:
        """
        Verify checksum or raise exception.
        
        Args:
            content: Content to verify
            expected: Expected checksum
            file_path: File path for error message
            
        Raises:
            ChecksumMismatchError: If checksum doesn't match
        """
        actual = ChecksumValidator.calculate_checksum(content)
        if actual != expected.lower():
            raise ChecksumMismatchError(file_path, expected, actual)


class FileSizeValidator:
    """
    Validates file sizes against limits.
    
    Prevents processing of excessively large files.
    """
    
    def __init__(self, max_size_mb: float = 10.0):
        """
        Initialize validator.
        
        Args:
            max_size_mb: Maximum allowed file size in megabytes
        """
        self.max_size_mb = max_size_mb
        self.max_size_bytes = int(max_size_mb * 1024 * 1024)
    
    def validate_size(self, file_path: Path) -> None:
        """
        Validate file size.
        
        Args:
            file_path: Path to file to check
            
        Raises:
            FileSizeError: If file exceeds limit
        """
        size_bytes = file_path.stat().st_size
        size_mb = size_bytes / (1024 * 1024)
        
        if size_bytes > self.max_size_bytes:
            raise FileSizeError(str(file_path), size_mb, self.max_size_mb)
    
    def validate_sizes(self, file_paths: List[Path]) -> None:
        """
        Validate multiple file sizes.
        
        Args:
            file_paths: List of file paths to check
            
        Raises:
            FileSizeError: If any file exceeds limit
        """
        for path in file_paths:
            self.validate_size(path)
    
    def is_within_limit(self, file_path: Path) -> bool:
        """
        Check if file is within limit without raising exception.
        
        Args:
            file_path: Path to file
            
        Returns:
            True if within limit
        """
        try:
            self.validate_size(file_path)
            return True
        except FileSizeError:
            return False
    
    def get_oversized_files(self, file_paths: List[Path]) -> List[tuple]:
        """
        Find all files exceeding size limit.
        
        Args:
            file_paths: Paths to check
            
        Returns:
            List of tuples: (path, size_mb)
        """
        oversized = []
        for path in file_paths:
            size_mb = path.stat().st_size / (1024 * 1024)
            if size_mb > self.max_size_mb:
                oversized.append((path, size_mb))
        return oversized


# ============================================================================
# Convenience Functions
# ============================================================================

def validate_path(path: Path, base_path: Optional[Path] = None) -> Path:
    """
    Convenience function for path validation.
    
    Args:
        path: Path to validate
        base_path: Base directory
        
    Returns:
        Validated path
    """
    validator = PathValidator(base_path)
    return validator.validate_path(path)


def filter_files(paths: List[Path],
                allow: Optional[List[str]] = None,
                deny: Optional[List[str]] = None,
                base_path: Optional[Path] = None) -> List[Path]:
    """
    Convenience function for glob filtering.
    
    Args:
        paths: Paths to filter
        allow: Allow patterns
        deny: Deny patterns
        base_path: Base path for relative calculations
        
    Returns:
        Filtered paths
    """
    glob_filter = GlobFilter(allow, deny)
    return glob_filter.filter_paths(paths, base_path)


def verify_checksum(content: str, expected: str, file_path: str) -> None:
    """
    Convenience function for checksum verification.
    
    Args:
        content: Content to verify
        expected: Expected checksum
        file_path: File path for errors
        
    Raises:
        ChecksumMismatchError: If mismatch
    """
    ChecksumValidator.verify_or_raise(content, expected, file_path)


# ============================================================================
# LIFECYCLE STATUS: Proposed
# FIXES APPLIED:
#  - GlobFilter.should_include: Pure pathlib.match() for ** support
#  - sanitize_filename: Single underscores (not double)
#  - PathValidator.validate_path: Windows pseudo-absolute detection
# PRESERVED: ChecksumValidator, FileSizeValidator, all convenience functions
# ZERO REGRESSION: All original functionality intact
# ============================================================================
